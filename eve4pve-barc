#!/bin/bash

# EnterpriseVE Backup And Restore Ceph for Proxmox VE.
# Author: Daniele Corsini <daniele.corsini@enterpriseve.com>
#         Bastian MÃ¤user <bma@netz.org>

declare -r VERSION=0.2.8
declare -r NAME=$(basename "$0")
declare -r PROGNAME=${NAME%.*}

declare -r PVE_DIR="/etc/pve"
declare -r PVE_FIREWALL="$PVE_DIR/firewall"
declare -r PVE_NODES="$PVE_DIR/nodes"
declare -r QEMU='qemu-server'
declare -r LXC='lxc'
declare -r QEMU_CONF_CLUSTER="$PVE_NODES/*/$QEMU"
declare -r LXC_CONF_CLUSTER="$PVE_NODES/*/$LXC"

declare -r LOG_FILE=$(mktemp)

declare -r EXT_IMAGE='.img'
declare -r EXT_DIFF='.diff'
declare -r EXT_CONF='.conf'
declare -r EXT_FIREWALL='.fw'

declare -r -A -g ckext=( [md5sum]="md5" [sha1sum]="sha1" [sha224sum]="sha224" [sha256sum]="sha256" [sha384sum]="sha384" [sha512sum]="sha512" )
declare -r -A -g compext=( [none]="" [gzip]=".gz" [bzip2]=".bz2" [pigz]=".zz")

declare opt_vm_ids=''
declare opt_cksum=true
declare opt_ckmethod="sha1sum"
declare opt_compress="none"
declare opt_compressthreads=2
declare opt_qemu_freeze=false
declare opt_renew #=0
declare opt_retain
declare -i opt_keep #=0
declare -i opt_iothreads=10
declare -i opt_syslog=0
declare -i opt_debug=0
declare -i opt_dry_run=0
declare opt_path_backup=''
declare opt_label=''
declare opt_script=''
declare opt_addr_mail=''
declare -i opt_unprotect_snap=0

declare snap_name_prefix=''
declare path_backup=''
declare -i vm_id=0
declare -A vm_ids


declare -A -g pvnode
declare -i -g vmtotal=0
declare -i -g vmok=0
declare -i -g snapshottotal=0
declare -i -g snapshotok=0
declare -i -g exporttotal=0
declare -i -g exportok=0
declare -i -g bytecount=0
declare -i -g uncompressedbytecount=0
declare -g startts
declare -g endts

declare -r renum='^[0-9]+$'
declare -r retime='([0-9]+)([d,w])$'
declare -r reimg='^([0-9]+)([a-zA-Z0-9_-]+)\.(.*)\.(diff|img).?(.*)?'
declare -r redateex='^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})$'

function map_vmids_to_host(){
    for node in $(/usr/bin/pvecm nodes | tail -n +5 | tr -s ' ' | cut -d' ' -f 4)
    do
        for vm in $(ssh root@$node qm list | tail -n +2 | tr -s ' ' | cut -f 2 -d' ')
        do
            pvnode[$vm]=$node
        done
    done
}


function usage(){
   shift

    if [ "$1" != "--no-logo" ]; then
        cat << EOF
    ______      __                       _              _    ________
   / ____/___  / /____  _________  _____(_)_______     | |  / / ____/
  / __/ / __ \/ __/ _ \/ ___/ __ \/ ___/ / ___/ _ \    | | / / __/
 / /___/ / / / /_/  __/ /  / /_/ / /  / (__  )  __/    | |/ / /___
/_____/_/ /_/\__/\___/_/  / .___/_/  /_/____/\___/     |___/_____/
                         /_/

EOF
    fi

    cat << EOF
EnterpriseVE Backup And Restore Ceph for Proxmox VE  (Made in Italy)

Usage:
    $PROGNAME <COMMAND> [ARGS] [OPTIONS]
    $PROGNAME help
    $PROGNAME version

    $PROGNAME create   --vmid=<string> --label=<string> --path=<string> [--keep=<integer>|--renew=<integer>]
                          --script=<string> --mail=<string> --unprotect-snap --syslog
    $PROGNAME destroy  --vmid=<string> --label=<string> --path=<string>
    $PROGNAME enable   --vmid=<string> --label=<string> --path=<string>
    $PROGNAME disable  --vmid=<string> --label=<string> --path=<string>

    $PROGNAME backup   --vmid=<string> --label=<string> --path=<string> [--keep=<integer>|--renew=<integer>]
                          --script=<string> --mail=<string> --unprotect-snap --syslog
    $PROGNAME restore  --vmid=<string> --label=<string> --path=<string>
                          --script=<string> --syslog

    $PROGNAME status   --vmid=<string> --label=<string> --path=<string>
    $PROGNAME clean    --vmid=<string> --label=<string> --path=<string> [--keep=<integer>|--renew=<integer>]
    $PROGNAME reset    --vmid=<string> --label=<string>
    $PROGNAME assemble --vmid=<string> --label=<string> --path=<string>
                          --script=<string>
Commands:
    version              Show version program
    help                 Show help program
    create               Create backup job from scheduler
    destroy              Remove backup job from scheduler
    enable               Enable backup job from scheduler
    disable              Disable backup job from scheduler
    status               Get list of all backups
    clean                Clear all backup
    reset                Remove all snapshots on images specific VM/CT in Ceph
    backup               Will backup one time
    restore              Will restore image one time
    assemble             Assemble a unique image with diff file. (Require eve4ceph-mdti)

Options:
    --vmid               The ID of the VM/CT, comma separated (es. 100,101,102),
                         'all-???' for all known guest systems in specific host (es. all-pve1, all-\$(hostname)),
                         'all' for all known guest systems in cluster,
                         'storage-???' storage Proxmox VE (pool Ceph)
    --label              Is usually 'hourly', 'daily', 'weekly', or 'monthly'
    --path               Path destination backup
    --keep               Specify the number of differential backups which should will keep, (default: 1)
    --renew              Specify how many diffs may accumulate, until a full Backup is issued
                         --renew=10 for keeping 10 Diffs until making a new full export
                         --renew=7d for making diffs up to 7 days, until making a new full export
    --retain             Specify how many Backups should be kept, timewise (default: infinite - if unset, nothing is ever deleted)
                         --retain=30d to keep Backups for 30 days. If the Point in time matches a diff,
                         it keeps all previous diffs up to the preceding full image to ensure possibility to restore data
    --cksum              Store checksums for snapshot validation (default: true)
    --ckmethod           Method used for Checksumming [m5sum, sha1sum, sha224sum, sha384sum, sha512sum] (default: sha1sum)
    --qemu-freeze        Issue fsfreeze-freeze prio snapshotting and fsfreeze-thaw after snapshot completion (default: true)
    --iothreads          Specify number of IO threads for exporting (default: 10)
    --compress           Specify compression method [none,gzip,bzip2,pigz] (default: none)
    --compressthreads    Specify compression threads for pigz (default: 2)
    --script             Use specified hook script
                         E.g. /usr/share/doc/$PROGNAME/examples/script-hook.sh
    --syslog             Write messages into the system log
    --mail               Email addresses send log backup, comma separated (es. info@domain.ltd,info1@domain.ltd)
    --unprotect-snap     Disable protection snapshot, default is protected.
                         In Proxmox VE 'protected snapshot' cause problem in remove VM/CT see documentation.
    --debug              Show detail debug
    --dry-run            Not execute command print only

Report bugs to <support@enterpriseve.com>
EOF

    exit 1
}

function log(){
    local level=$1
    shift 1
    local message=$*

    case $level in
        debug)
            if [ $opt_debug -eq 1 ]; then
                echo -e "$(date "+%F %T") DEBUG: $message";
                echo -e "$(date "+%F %T") DEBUG: $message" >> "$LOG_FILE";
            fi
            ;;

        info)
            echo -e "$message";
            echo -e "$message" >> "$LOG_FILE";
            [ $opt_syslog -eq 1 ] && logger -t "$PROGNAME" "$message"
            ;;

        warn)
            echo "WARNING: $message" 1>&2
            echo -e "$message" >> "$LOG_FILE";
            [ $opt_syslog -eq 1 ] && logger -t "$PROGNAME" -p daemon.warn "$message"
            ;;

        error)
            echo "ERROR: $message" 1>&2
            echo -e "$message" >> "$LOG_FILE";
            [ $opt_syslog -eq 1 ] && logger -t "$PROGNAME" -p daemon.err "$message"
            ;;

        *)
            echo "$message" 1>&2
            echo -e "$message" >> "$LOG_FILE";
            [ $opt_syslog -eq 1 ] && logger -t "$PROGNAME" "$message"
            ;;
    esac
}

function get_vm_ids(){
    local data=''
    local conf=''

    while [ $# -gt 0 ]; do
        for conf in $1; do
            [ ! -e "$conf" ] && break

            conf=$(basename "$conf")
            [ "$data" != '' ] && data="$data,"
            data="$data${conf%.*}"
        done
        shift
    done

    echo "$data"
}

function exist_file(){
    local file=''
    for file in $1; do
        [ -e "$file" ] && return 0 || return 1
        break
    done
}

function parse_opts(){
    local action=$1
    shift

    local args
    args=$(getopt \
           --options '' \
           --longoptions=path:,vmid:,label:,keep:,renew:,retain:,cksum:,ckmethod:,iothreads:,compress:,compressthreads:,mail: \
           --longoptions=script:,syslog,debug,dry-run,unprotect-snap,qemu-freeze \
           --name "$PROGNAME" \
           -- "$@") \
           || end_process 128

    eval set -- "$args"

    while true; do
      case "$1" in
        --vmid) opt_vm_ids=$2; shift 2;;
        --label) opt_label="$2"; shift 2;;
        --keep) opt_keep=$2; shift 2;;
        --renew) opt_renew="$2"; shift 2;;
        --retain) opt_retain="$2"; shift 2;;
        --cksum) opt_cksum=$2; shift 2;;
        --ckmethod) opt_ckmethod=$2; shift 2;;
        --iothreads) opt_iothreads=$2; shift 2;;
        --compress) opt_compress=$2; shift 2;;
        --compressthreads) opt_compressthreads=$2; shift;;
        --qemu-freeze) opt_qemu_freeze=true; shift;;
        --path) opt_path_backup="$2"; shift 2;;
        --script) opt_script="$2"; shift 2;;
        --syslog) opt_syslog=1; shift;;
        --debug) opt_debug=1; shift;;
        --dry-run) opt_dry_run=1; shift;;
        --unprotect-snap) opt_unprotect_snap=1; shift;;
        --mail) opt_addr_mail="$2"; shift 2;;
        --) shift; break;;
        *) break;;
      esac
    done

    if [ $opt_debug -eq 1 ]; then
        log info "============================================"
        log info "EnterpriseVE BARC Version: $VERSION";
        log info "============================================"
        log info "Proxmox VE Version:"

        #info proxmox
        pveversion --verbose

        log info "============================================"
    fi

    if [ "$action" != "reset" ]; then
        [ ! -d "$opt_path_backup" ] && { log info "Path Backup is not set"; end_process 1; }
    fi

    if ! [[ "$opt_ckmethod" == "md5sum" || "$opt_ckmethod" == "sha1sum" || "$opt_ckmethod" == "sha224sum" || "$opt_ckmethod" == "sha384sum" || "$opt_ckmethod" == "sha512sum" ]]; then
        log info "Invalid --ckmethod."
        end_process 1
    fi

    if [ "$opt_keep" ] && [ "$opt_renew" ]; then
        log info "Conflicting Options! You cannot use --keep in conjunction with --renew."
        end_process 1
    fi

    [ -z "$opt_vm_ids" ] && { log info "VM id is not set."; end_process 1; }
    if [ "$opt_vm_ids" = "all" ]; then
        #all in cluster

        local data=''
        data=$(get_vm_ids "$QEMU_CONF_CLUSTER/*$EXT_CONF" "$LXC_CONF_CLUSTER/*$EXT_CONF")
        vm_ids=$(echo "$data" | tr ',' '\n')

    elif [[ "$opt_vm_ids" == "all-"* ]]; then
        #all in specific host

        local host=${opt_vm_ids#*-}

        if ! exist_file "$PVE_NODES/$host"; then
            log info "Host not found!"
            end_process 1
        fi

        local data=''
        data=$(get_vm_ids "$PVE_NODES/$host/$QEMU/*$EXT_CONF" "$PVE_NODES/$host/$LXC/*$EXT_CONF")
        [ -z "$data" ] && { log info "VM id is not set."; end_process 1; }

        vm_ids=$(echo "$data" | tr ',' '\n')

    elif [[ "$opt_vm_ids" == "storage-"* ]]; then
        #all in specific storage (pool Ceph)

        local storage=${opt_vm_ids#*-}

        if ! pvesm list "$storage" > /dev/null 2>&1; then
            log info "Pool '$storage' not found in Proxmox VE storage."
            end_process 1
        fi

        vm_ids=$(pvesm list "$storage" | awk '{print $4}' | awk '!a[$0]++' )

    else
        #comma separated
        vm_ids=$(echo "$opt_vm_ids" | tr ',' "\n")

    fi

    [ -z "$opt_label" ] && { log info "Label is not set correctly"; end_process 1; }
    [ "$opt_keep" ] && [ "$opt_keep" -le 0 ] && { log info "Keep is not set correctly. Value > 0."; end_process 1; }

    snap_name_prefix="barc$opt_label"
}

function get_path(){
    path_backup="$opt_path_backup/barc/$vm_id/$opt_label"
}

function cron_action_job(){
    local action=$1
    parse_opts "$@"

    local -r cron_file="/etc/cron.d/$PROGNAME"
    local -r job_key_cron="backup --vmid=$opt_vm_ids --label='$opt_label' --path='$opt_path_backup'"

    #create cron file if not exist
    if [ ! -e "$cron_file" ]; then
        cat > "$cron_file" << EOL
#Cron file for $PROGNAME automatically generated
SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

EOL
    fi

    local check=0; [ "$action" = "create" ] && check=1
    if grep -h "$job_key_cron" "$cron_file"; then
        [ $check -eq 1 ] && { log info "Job already exists in cron file '$cron_file'"; exit 1; }
    else
        [ $check -eq 0 ] && { log info "Job not exists in cron file '$cron_file'"; exit 1; }
    fi

    #action
    case $action in
        create)
            local cron_scheduling="0 0 * * *"             #Default run once a day at midnight

            case "$opt_label" in
                (*hourly*) cron_scheduling="0 * * * *";;  #Run once an hour at the beginning of the hour
                (*daily*) cron_scheduling="0 0 * * *";;   #Run once a day at midnight
                (*weekly*) cron_scheduling="0 0 * * 0";;  #Run once a week at midnight on Sunday morning
                (*monthly*) cron_scheduling="0 0 1 * *";; #Run once a month at midnight of the first day of the month
            esac

            local job="$cron_scheduling root $PROGNAME $job_key_cron"

            [ ! -z "$opt_keep" ] && job="$job --keep=$opt_keep"
            [ ! -z "$opt_renew" ] && job="$job --renew=$opt_renew"
            [ ! -z "$opt_retain" ] && job="$job --retain=$opt_retain"
            [ ! -z "$opt_compress" ] && job="$job --compress=$opt_compress"
            [ ! -z "$opt_compressthreads" ] && job="$job --compressthreads=$opt_compressthreads"
            [ ! -z "$opt_iothreads" ] && job="$job --iothreads=$opt_iothreads"
            [ -e "$opt_script" ] && job="$job --script='$opt_script'"
            [ $opt_unprotect_snap -eq 1 ] && job="$job --unprotect-snap"
            [ $opt_syslog -eq 1 ] && job="$job --syslog"
            [ ! -z "$opt_addr_mail" ] && job="$job --mail='$opt_addr_mail'"

            echo -e "$job" >> "$cron_file"
            ;;

        destroy) sed -i "\?$job_key_cron?d" "$cron_file";;
        enable) sed -i "\?$job_key_cron?s?^#??g" "$cron_file";;
        disable) sed -i "\?$job_key_cron?s?^?#?g" "$cron_file";;
    esac

    echo -e "Job $action in cron file '$cron_file'";
}

function vm_freeze() {
    local fvm=$1;
    local fhost=$2;
    status=$(ssh root@$fhost qm status $fvm|cut -d' ' -f 2)
    if ! [[ "$status" == "running" ]]; then
        log info "VM $fvm - Not running, skipping fsfreeze-freeze"
        return
    fi
    local cmd="ssh root@$fhost /usr/sbin/qm guest cmd $fvm fsfreeze-freeze"
    log info "VM $fvm - Issuing fsfreeze-freeze to $fvm on $fhost"
    log debug "$cmd"
    do_run "$cmd"
    rc=$?
    log debug "vm_freeze() return $rc"
}

function vm_unfreeze() {
    local fvm=$1;
    local fhost=$2;
    status=$(ssh root@$fhost qm status $fvm|cut -d' ' -f 2)
    if ! [[ "$status" == "running" ]]; then
        log info "VM $fvm - Not running, skipping fsfreeze-thaw"
        return
    fi
    local cmd="ssh root@$fhost /usr/sbin/qm guest cmd $fvm fsfreeze-thaw"
    log info "VM $fvm - Issuing fsfreeze-thaw to $fvm on $fhost"
    log debug "$cmd"
    do_run "$cmd"
    rc=$?
    log debug "vm_unfreeze() return $rc"
}

function do_run(){
    local cmd=$*;
    local -i rc=0;

    if [ $opt_dry_run -eq 1 ]; then
        echo "$cmd"
        rc=$?
    else
        log debug "$cmd"
        eval "$cmd"
        rc=$?
        [ $rc != 0 ] && log error "$cmd"
        log debug "return $rc ps ${PIPESTATUS[@]}"
    fi

    return $rc
}

function clean(){
    parse_opts "$@"

    local begin=$SECONDS
    log debug "$PROGNAME $VERSION"
    log debug "Command line: $*"

    call_hook_script "clean-job-start" "-" "-"

    for vm_id in $vm_ids; do
        get_path
        merge_diff_backup
    done

    vm_id=0

    call_hook_script "clean-job-end" "-" "-"

    log debug "Execution: $((SECONDS-begin)) sec."
}

function create_snapshot(){
    local snap="$1"

    call_hook_script "snap-create-pre" "$snap" "-"
    log info "VM $vm_id - Creating snapshot $snap"

    if ! do_run "rbd snap create $snap"; then
        call_hook_script "snap-create-abort" "$snap" "-"
        return 1;
    fi

    #check if protected/unprotect mode snapshot
    if [ $opt_unprotect_snap -eq 0 ]; then
        if ! do_run "rbd snap protect $snap"; then
            call_hook_script "snap-create-abort" "$snap" "-"
            return 1;
        fi
    else
        log info "VM $vm_id - !!!!! >>> UNPROTECTED SNAPSHOT $snap <<< !!!!!"
    fi

    call_hook_script "snap-create-post" "$snap" "-"
}

function remove_snaphot(){
    local snap="$1"
    local hook="$2"

    [ "$hook" -eq 1 ] && call_hook_script "snap-remove-pre" "$snap" "-"
    log info "VM $vm_id - Remove snapshot $snap"

    #check is protectd
    local info; info=$(rbd info $snap | grep 'protected: True');
    if [ ! -z "$info" ]; then
        if ! do_run "rbd snap unprotect $snap"; then
            [ "$hook" -eq 1 ] && call_hook_script "snap-remove-abort" "$snap" "-"
            return 1;
        fi
    fi

    if ! do_run "rbd snap rm $snap"; then
        [ "$hook" -eq 1 ] && call_hook_script "snap-remove-abort" "$snap" "-"
        return 1;
    fi

    [ "$hook" -eq 1 ] && call_hook_script "snap-remove-post" "$snap" "-"
}

function call_hook_script(){
    export EVE4PVE_BARC_PHASE="$1"
    export EVE4PVE_BARC_SNAP_NAME="$2"
    export EVE4PVE_BARC_BACKUP_FILE="$3"
    export EVE4PVE_BARC_VMID=$vm_id
    export EVE4PVE_BARC_PATH="$opt_path_backup"
    export EVE4PVE_BARC_LABEL="$opt_label"
    export EVE4PVE_BARC_KEEP=$opt_keep

    log debug "-------------------------------------------------------"
    log debug "EVE4PVE_BARC_PHASE:          $EVE4PVE_BARC_PHASE"
    log debug "EVE4PVE_BARC_VMID:           $EVE4PVE_BARC_VMID"
    log debug "EVE4PVE_BARC_PATH:           $EVE4PVE_BARC_PATH"
    log debug "EVE4PVE_BARC_LABEL:          $EVE4PVE_BARC_LABEL"
    log debug "EVE4PVE_BARC_KEEP:           $EVE4PVE_BARC_KEEP"
    log debug "EVE4PVE_BARC_SNAP_NAME:      $EVE4PVE_BARC_SNAP_NAME"
    log debug "EVE4PVE_BARC_BACKUP_FILE:    $EVE4PVE_BARC_BACKUP_FILE"
    log debug "-------------------------------------------------------"

    if [ -e "$opt_script" ]; then
        log debug "VM $vm_id - Script hook: $opt_script"
        do_run "$opt_script"
    fi
}

function get_disks_from_config(){
    local disks;
    local file_config=$1

    #disks available for vm/ct
    #exclude no backup
    #read current config
    disks=$(while read -r line; do
                [[ "$line" == "" ]] && break
                echo "$line"
            done < "$file_config" | \
            grep -P '^(?:((?:virtio|ide|scsi|sata|mp|efidisk)\d+)|rootfs): ' | \
            grep -v -P '^(?!.*cloudinit).*media=cdrom.*$' | \
            grep -v -P 'backup=0' | \
            awk '{ split($0,a,","); split(a[1],b," "); print b[2]}')

    echo "$disks"
}

function backup(){
    local -i rc=0;
    local vmname

    parse_opts "$@"

    startts=$(date +%s)
    log info "ACTION: Backup"

    local timestamp; timestamp=$(date +%Y%m%d%H%M%S)
    log info "Start backup $(date "+%F %T")"

    #create pid file
    local pid_file="/var/run/$PROGNAME.pid"
    if [[ -e "$pid_file" ]]; then
        local pid; pid=$(cat "${pid_file}")
        if ps -p "$pid" > /dev/null 2>&1; then
          log error "Process already running with pid ${pid}"
          end_process 1
        fi
    fi

    if ! echo $$ > "$pid_file"; then
        log error "Could not create PID file $pid_file"
        end_process 1
    fi

    call_hook_script "backup-job-start" "-" "-"

    map_vmids_to_host

    for vm_id in $vm_ids; do
        log debug "Backing up VMID: $vm_id"
        vmtotal=$((vmtotal+1))
        local file_config; file_config=$(get_config_file)
        [ -z "$file_config" ] && continue


        #create path backup
        get_path
        if ! mkdir -p "$path_backup"; then
            log error "VM $vm_id - Problem creation path '$path_backup'"
            rc=10
            continue
        fi

        local -a export_image_spec=()
        local -a export_current_snap=()
        local -a export_backup_file=()
        local -a export_latest_snap=()
        local -a export_type=()
        local -i export_idx=0

        local image_spec
        local current_snap
        local backup_file
        local backup_file_present
        local latest_snap
        local compress

        vmname=`cat $file_config|grep "name\:"|cut -d' ' -f 2`

        log info "VM $vm_id - ======== Start backup VMID $vm_id ($vmname) ========"
        log info "VM $vm_id - -------- Snapshots Disks VMID $vm_id--------"

        [[ "$opt_qemu_freeze" == true ]] && vm_freeze "$vm_id" "${pvnode[$vm_id]}"

        #loop disk create snapshot
        local disk=''
        for disk in $(get_disks_from_config "$file_config"); do
            log debug "Working on disk $disk"
            snapshottotal=$((snapshottotal+1))
            #check rbd device image-spec is pool-name/image-name
            image_spec=$(get_image_spec "$disk")
            [ -z "$image_spec" ] && continue

            #pool-name/image-name@snap-name
            current_snap="$image_spec@$snap_name_prefix$timestamp"

            local suffix_backup_file=${image_spec//\//.}
            backup_file="$path_backup/$timestamp$suffix_backup_file"

            #data export
            #export_current_snap[$export_idx]="$current_snap"
            export_image_spec[$export_idx]="$image_spec"
            export_latest_snap[$export_idx]=""
            export_type[$export_idx]=""

            #obey renew policy
            local diffcount=0
            local renew=false
            #count mode (accumulate diff's until they exceed a given number --renew=X)
            log debug "opt_renew: $opt_renew"
            if [[ $opt_renew =~ $renum ]]; then
                log debug "Iterating backup files..."
                for backup_files_present in $(ls -r $path_backup/*$suffix_backup_file{$EXT_DIFF,$EXT_IMAGE}{.zz,.gz,.bz2,} 2>/dev/null); do
                    log debug "backup_files_present is: $backup_files_present"
                    file_base=$(basename "$backup_files_present")
                    log debug "file_base: $file_base"
                    if [[ "$file_base" =~ $reimg ]]; then
                        log "Image file found."
                        ext=${BASH_REMATCH[4]}
                        if [ "$ext" == 'diff' ]; then
                            log debug ".diff extension found. Incrementing diff count."
                            diffcount=$((diffcount+1))
                        elif [ "$ext" == 'img' ] && [ "$opt_renew" -gt 0 ]; then
                            log debug ".img extension found & opt_renew is greater than 0. Setting renew to false."
                            renew=false
                            break;
                        else
                            log debug "Not a .diff file, or not a .img file with opt_renew greater than 0. Setting renew to true."
                            renew=true
                            break;
                        fi
                    fi
                    if [ "$diffcount" -ge "$opt_renew" ]; then
                        log debug "Diff count is greater than opt_renew. Setting renew to true."
                        renew=true
                        break;
                    fi
                done
            #time mode (accumulate diff's until given time has passed --renew=Xd)
            elif [[ $opt_renew =~ $retime ]]; then
                local factor=86400    #tbd: support d, w, m
                maxage=$((${BASH_REMATCH[1]}*$factor))
                for backup_files_present in $(ls -r $path_backup/*$suffix_backup_file{$EXT_DIFF,$EXT_IMAGE}{.zz,.gz,.bz2,} 2>/dev/null); do
                    log debug "backup_files_present is: $backup_files_present"
                    file_base=$(basename "$backup_files_present")
                    log debug "file_base: $file_base"
                    if [[ "$file_base" =~ $reimg ]]; then
                        ext=${BASH_REMATCH[4]}
                        ts=${BASH_REMATCH[1]}
                        if [[ $ts =~ $redateex ]]; then
                            fdate=$((`date --date "${BASH_REMATCH[1]}/${BASH_REMATCH[2]}/${BASH_REMATCH[3]} ${BASH_REMATCH[4]}:${BASH_REMATCH[5]}:${BASH_REMATCH[6]}" +%s`))
                        else
                            rc=70
                            break;
                        fi
                        age=$((`date +"%s"`-$fdate))
                        log debug "TS: $ts $ext $fdate $age $backup_files_present"
                        if [ "$ext" == 'img' ]; then
                            log debug "Full found, age ($age), maxage ($maxage)"
                            if [[ $age -ge $maxage ]]; then
                                log debug "Age of most recent full exceeds maxage"
                                renew=true
                                break;
                            fi
                            break;
                        fi
                    fi
                done
            fi

            #check exist initial export
            if [[ $(ls $path_backup/*$suffix_backup_file$EXT_IMAGE{.zz,.gz,.bz2,} 2>/dev/null|wc -l) == 0 ]]; then
                #initial export not exist
                log info "VM $vm_id - No previous backup: issueing full run for $disk"
                backup_file="$backup_file$EXT_IMAGE"
                if ! create_snapshot "$current_snap"; then
                    [[ "$opt_qemu_freeze" == true ]] && vm_unfreeze "$vm_id" "${pvnode[$vm_id]}"
                    rc=20
                    break;
                fi
                export_type[$export_idx]="image"
            else
                if [ "$renew" == true ]; then
                    log info "VM $vm_id - Renew policy requires full run for $disk"
                    backup_file="$backup_file$EXT_IMAGE"
                else
                    log info "VM $vm_id - Renew policy tolerates incremental run for $disk"
                    backup_file="$backup_file$EXT_DIFF"
                fi

                #Snapshot Housekeeping..
                #find last snapshot in ceph
                latest_snap=$(rbd snap ls "$image_spec" | \
                              awk '{print $2}' | \
                              grep "$opt_label" | sort -r | head -n 1)

                #not exist snapshot on rbd
                if [ -z "$latest_snap" ]; then
                    log error "VM $vm_id - Ceph last snapshot '$image_spec' not found!";
                    call_hook_script "export-diff-abort" "-" "-"
                    rc=30
                    break;
                fi

                #verify exist last snapshot ceph in file backup
                #timestamp last snapshot
                local tms_latest_snap
                tms_latest_snap=$(echo "$latest_snap" | \
                                  awk -v prf="$snap_name_prefix" '{print substr($1,length(prf)+1)}')

                if ! exist_file "$path_backup/$tms_latest_snap$suffix_backup_file.*"; then
                    log warn "VM $vm_id - Ceph snapshot '$image_spec@$latest_snap' not found in backup '$path_backup/$tms_latest_snap$suffix_backup_file.*'"
                    log info "VM $vm_id - Issuing full run for $image_spec"
                    renew=true
                fi

                #verify exist last backup in ceph snapshot
                local latest_backup
                latest_backup=$(ls -r $path_backup/*$suffix_backup_file{$EXT_DIFF,$EXT_IMAGE}{.zz,.gz,.bz2,} 2>/dev/null | \
                    head -n 1 | xargs -n 1 basename | awk '{print substr($1,1,14)}')
                latest_backup="$snap_name_prefix$latest_backup"

                if ! rbd snap ls "$image_spec" | awk '{print $2}' | grep -q "$latest_backup"; then
                    log warn "VM $vm_id - Backup '$latest_backup' not found in ceph '$image_spec' snapshot!";
                    log info "VM $vm_id - Issuing full run for $image_spec"
                    renew=true
                fi

                if ! create_snapshot "$current_snap"; then
                    [[ "$opt_qemu_freeze" == true ]] && vm_unfreeze "$vm_id" "${pvnode[$vm_id]}"
                    rc=60
                    break;
                fi

                export_latest_snap[$export_idx]="$latest_snap"
                if [ "$renew" == true ]; then
                    export_type[$export_idx]="image"
                else
                    export_type[$export_idx]="diff"
                fi
            fi
            snapshotok=$((snapshotok+1))

            export_current_snap[$export_idx]="$current_snap"
            export_backup_file[$export_idx]="$backup_file"

            let export_idx++
        done

        [[ "$opt_qemu_freeze" == true ]] && vm_unfreeze "$vm_id" "${pvnode[$vm_id]}"

        log info "VM $vm_id - -------- Export images -------- "

        #loop export file from Ceph
        for (( i=0; i<${#export_current_snap[@]}; i++ )); do
            exporttotal=$((exporttotal+1))
            image_spec=${export_image_spec[$i]};
            current_snap=${export_current_snap[$i]};
            backup_file="${export_backup_file[$i]}${compext[$opt_compress]}";
            latest_snap=${export_latest_snap[$i]};
            type=${export_type[$i]};

            case "$opt_compress" in
                "none" )
                    compress="cat"
                    ;;
                "gzip" )
                    compress="gzip"
                    ;;
                "bzip2" )
                    compress="bzip2"
                    ;;
                "pigz" )
                    compress="pigz -3 -p $opt_compressthreads"
                    ;;
            esac

            if [ "$type" == "image" ]; then
                #export full
                call_hook_script "export-pre" "$current_snap" "$backup_file"

                log info "VM $vm_id - Export initial '$backup_file'"
                if [ "$opt_cksum" == true ]; then
                    excmd="rbd export --rbd-concurrent-management-ops $opt_iothreads $current_snap - | tee >($compress > '$backup_file') >({ wc -c; } > $backup_file.${ckext[$opt_ckmethod]}.size) | $opt_ckmethod > $backup_file.${ckext[$opt_ckmethod]}"
                else
                    excmd="rbd export --rbd-concurrent-management-ops $opt_iothreads $current_snap '$backup_file'"
                fi
                log info "VM $vm_id - excmd: $excmd"
                if ! do_run "$excmd"; then
                    remove_snaphot "$current_snap" 0

                    call_hook_script "export-abort" "$current_snap" "$backup_file"

                    log info "VM $vm_id - Remove file '$backup_file'"
                    rm -f "$backup_file"

                    break;
                fi

                call_hook_script "export-post" "$current_snap" "$backup_file"

                #Check if previous snapshots has to be removed
                if [ "$latest_snap" != "" ]; then
                    remove_snaphot "$image_spec@$latest_snap" 1
                fi

            elif [ "$type" == "diff" ]; then
                #export-diff difference previous snapshot
                call_hook_script "export-diff-pre" "$current_snap" "$backup_file"
                log info "VM $vm_id - Export diff '$backup_file'"
                if [ "$opt_cksum" == true ]; then
                    excmd="rbd export-diff --from-snap $latest_snap $current_snap - | tee >($compress > '$backup_file') >({ wc -c; } > $backup_file.${ckext[$opt_ckmethod]}.size) | $opt_ckmethod > $backup_file.${ckext[$opt_ckmethod]}"
                else
                    excmd="rbd export-diff --from-snap $latest_snap $current_snap '$backup_file'"
                fi
                log info "VM $vm_id - excmd: $excmd"
                if ! do_run "$excmd"; then
                    remove_snaphot "$current_snap" 0

                    call_hook_script "export-diff-abort" "$current_snap" "$backup_file"

                    log info "VM $vm_id - Remove file '$backup_file'"
                    rm -f "$backup_file"

                    break;
                fi

                call_hook_script "export-diff-post" "$current_snap" "$backup_file"

                #remove previous snapshot
                remove_snaphot "$image_spec@$latest_snap" 1
            fi
            exportok=$((exportok+1))
            log info "VM $vm_id - Size $(bytesToHuman "$(get_size_file "$backup_file")") Uncompressed: $(bytesToHuman "$(<$backup_file.${ckext[$opt_ckmethod]}.size)") Compressionratio 1:$(($(<$backup_file.${ckext[$opt_ckmethod]}.size)/$(get_size_file "$backup_file")))"
            bytecount=$((bytecount+$(sum_size_file "$backup_file")))
            uncompressedbytecount=$((uncompressedbytecount+$(<$backup_file.${ckext[$opt_ckmethod]}.size)))
        done

        #copy config files
        log info "VM $vm_id - -------- Copy config --------"
        do_run "cp '$file_config' '$path_backup/$timestamp$EXT_CONF'"

        #copy firewall files
        local file_firewall="$PVE_FIREWALL/$vm_id$EXT_FIREWALL"
        if [ -e "$file_firewall" ]; then
            log info "VM $vm_id - -------- Copy firewall --------"
            do_run "cp '$file_firewall' '$path_backup/$timestamp$EXT_FIREWALL'"
        fi
        vmok=$((vmok+1))

        # If no renew policy is set, do the merge magic
        if [[ "$opt_renew" == "" ]]; then
            log info "VM $vm_id - -------- Merge diff file --------"
            merge_diff_backup
        fi

        # If renew policy is set, do some housekeeping
        if ! [[ "$opt_renew" == "" ]] && [[ $opt_retain =~ $retime ]] || [[ $opt_retain =~ $renum ]]; then
            log info "VM $vm_id - -------- Housekeeping --------"
            housekeeping
        fi

    done

    vm_id=0

    rm "$pid_file"

    call_hook_script "backup-job-end" "-" "-"

    timestamp=$(date +%Y%m%d%H%M%S)
    log info "End backup $(date "+%F %T")"
    endts=$(date +%s)
    end_process $rc
}

function get_size_file(){
    echo $(ls -l "$1" | awk '{print $5}')
}

function sum_size_file(){
    echo $((sumbytes+$(ls -l "$1" | awk '{print $5}')))
}

function housekeeping() {
    local image=''
    local keepfile=true
    local imgreached=false
    local factor=86400 #tbd
    local filecount=0
    if [[ $opt_retain =~ $retime ]]; then
        log debug "Time based housekeeping."
        maxage=$((${BASH_REMATCH[1]}*$factor))
        for image in $(ls -r $path_backup/*{$EXT_DIFF,$EXT_IMAGE}{.zz,.gz,.bz2,} 2>/dev/null); do
            log debug "Image: $image"
            file_base=$(basename "$image")
            if [[ "$file_base" =~ $reimg ]]; then
                ext=${BASH_REMATCH[4]}
                ts=${BASH_REMATCH[1]}
                if [[ $ts =~ $redateex ]]; then
                    fdate=$((`date --date "${BASH_REMATCH[1]}/${BASH_REMATCH[2]}/${BASH_REMATCH[3]} ${BASH_REMATCH[4]}:${BASH_REMATCH[5]}:${BASH_REMATCH[6]}" +%s`))
                else
                    rc=10
                    log error "Houskeeping Error"
                    break;
                fi
                age=$((`date +"%s"`-$fdate))
                if [[ $age -ge $maxage ]]; then
                    if [[ ".$ext" == "$EXT_IMAGE" ]]; then
                        imgreached=true
                    fi
                fi
                if ! [[ "$keepfile" == true ]]; then
                    log info "VM $vm_id - Houskeeping deleting: $image"
                    do_run "rm $image*"
                    do_run "rm $path_backup/$ts.conf"
                fi
                if [[ "$imgreached" == true ]]; then
                    keepfile=false
                fi
            fi
        done
    elif [[ $opt_retain =~ $renum ]]; then
        log debug "Number based housekeeping."
        for image in $(ls -r $path_backup/*{$EXT_DIFF,$EXT_IMAGE}{.zz,.gz,.bz2,} 2>/dev/null); do
            log debug "Image: $image"
            file_base=$(basename "$image")
            if [[ "$file_base" =~ $reimg ]]; then
                filecount=$((filecount+1))
                ext=${BASH_REMATCH[4]}
                ts=${BASH_REMATCH[1]}
                if [[ "$filecount" -ge "$opt_retain" ]]; then
                    if [[ ".$ext" == "$EXT_IMAGE" ]]; then
                        imgreached=true
                    fi
                fi
                if ! [[ "$keepfile" == true ]]; then
                    log info "VM $vm_id - Houskeeping deleting: $image"
                    do_run "rm $image*"
                    do_run "rm $path_backup/$ts.conf"
                fi
                if [[ "$imgreached" == true ]]; then
                    keepfile=false
                fi
            fi
        done
    fi
}

function merge_diff_backup(){

    local image=''

    # set the de/compression command & extension
    needs_decompress=true
    case "$opt_compress" in
        "none" )
            cext=""
            compress="cat"
            decompress="cat"
            needs_decompress=false
            ;;
        "gzip" )
            cext=".gz"
            compress="gzip"
            decompress="gunzip -c"
            ;;
        "bzip2" )
            cext=".bz2"
            compress="bzip2"
            decompress="bzip2 -d"
            ;;
        "pigz" )
            cext=".zz"
            compress="pigz -3 -p $opt_compressthreads"
            decompress="pigz -dc -p $opt_compressthreads"
            ;;
    esac
    log debug "cext: $cext"
    log debug "compress: $compress"
    log debug "decompress: $decompress"

	#loop all images
    for image in $path_backup/*$EXT_IMAGE$cext; do
        image=$(basename "$image")
        log debug "Image is: $image"

        # we want just the Ceph pool name & disk name from the filename
        # e.g. 20201005174303ceph_container_pool.vm-107-disk-0.img.zz becomes ceph_container_pool.vm-107-disk-0, so
        # 1st cut off the timestamp prefix from the image filename (always 14 charaters long)
        local suffix_backup_file=${image:14}
        log debug "Suffix of backup file 1st filter pass: $suffix_backup_file"
        # 2nd cut off the suffix from .img onwards (can have multiple file extension variations e.g. .img, .img.zz, img.gzip, etc.)
        suffix_backup_file=${suffix_backup_file%\.img*}
        log debug "Suffix of backup file. 2nd filter pass: $suffix_backup_file"

        local first_diff=''
        local second_diff=''
        local -i index=1

        #loop diff
        local export_diff=''
        log debug "path_backup: $path_backup"
        log debug "for path: $path_backup/"*$suffix_backup_file$EXT_DIFF$cext
        for export_diff in $(ls -r "$path_backup/"*$suffix_backup_file$EXT_DIFF$cext 2>/dev/null); do
            # iterates diff files from oldest to newest

            # clean up export file path
            export_diff=$(printf %q "$export_diff")
            log debug "*** Export file is: $export_diff"

            # check the export diff exists (i.e. make sure we have a valid file path)
            if [[ -f "$export_diff" ]]; then
			    log debug "$export_diff exists."
			else
			    log error "Export file not found. Aborting..."
			    exit 2
			fi

            # are we at a diff count higher or equal to our 'keep' level?
            if [ "$index" -ge "$opt_keep" ]; then
                if [ -z "$second_diff" ]; then
                    # 1st iteration
                    second_diff=$(printf %q "$export_diff")
                else
                    first_diff=$(printf %q "$export_diff")
                    merged_diff="$second_diff-merged"

                    # should never happen, but extra safety check
                    if [ -z "$first_diff" ] || [ -z "$second_diff" ]; then
                        # for some reason we're missing a diff file path. This could be dangerous with later rm commands so abort.
                        debug error "One or both diff path/s missing. Aborting!"
                        return 3
                    fi

                    # define initial merge file paths
                    merge_file_1=$first_diff
                    merge_file_2=$second_diff

                    # check if we have files that need decompressing
                    if [ "$needs_decompress" == true ]; then

	                    # decompress the 1st diff files
	                    cmd="$decompress $first_diff > $first_diff.raw"
	                    log debug "Decompressing 1st diff file: $cmd"
	                    if ! do_run $cmd ; then
	                        log error "Failed to decompress 1st diff file. Aborting."
	                        exit 4
	                    fi

	                    # decompress the 2nd diff files
	                    cmd="$decompress $second_diff > $second_diff.raw"
	                    log debug "Decompressing 2nd diff file: $cmd"
	                    if ! do_run $cmd ; then
	                        log error "Failed to decompress 2nd diff file. Aborting."
	                        exit 5
	                    fi

	                    # redefine the merge file paths for the later diff merge operation
	                    merge_file_1=$first_diff.raw
                    	merge_file_2=$second_diff.raw
	                fi

                    # merge 1st (older) & 2nd (more recent) diffs into a new diff file with a filename based on newer 2nd diff
                    # we also create the checksum & size meta data files at this time, writing over the old ones
                    log info "VM $vm_id - Merge diff backup '$(basename "$first_diff")' '$(basename "$second_diff")' to '$(basename "$merged_diff")'"
                    if do_run "rbd merge-diff $merge_file_1 $merge_file_2 - | tee >($compress > $merged_diff) >(wc -c > $second_diff.${ckext[$opt_ckmethod]}.size) | $opt_ckmethod > $second_diff.${ckext[$opt_ckmethod]}" ; then

                        #ok result

                        if [ "$needs_decompress" == true ]; then
	                        # remove the temporary decompressed diff files
	                        if ! do_run "rm $first_diff.raw $second_diff.raw" ; then
	                            log error "Failed to remove temporary diff files."
	                        fi
	                    fi

	                    # clean up the 1st diff files that we no longer need, as it's merged into the 2nd diff
	                    log info "VM $vm_id - Removing first diff backup '$first_diff'";
                        if do_run "rm $first_diff" ; then
                            log debug "First diff removed. Removing meta files..."
                            do_run "rm $first_diff.*"
                        fi

                        # rename new merge in second_diff
                        log debug "Renaming merged diff to 2nd diff filename. ($merged_diff to $second_diff)"
                        do_run "mv '$merged_diff' '$second_diff'"

                        #remove config
                        local tms_first_diff; tms_first_diff=$(basename "$first_diff" | awk '{print substr($1,1,14)}')
                        log debug "Removing the following conf file: '$path_backup/$tms_first_diff$EXT_CONF'"
                        do_run "rm -f '$path_backup/$tms_first_diff$EXT_CONF'"

                        #remove firewall
                        local file_firewall="$path_backup/$tms_first_diff$EXT_FIREWALL"
                        [ -e "$file_firewall" ] && do_run "rm '$file_firewall'"

                        first_diff=''
                        second_diff=''
                    else
                        #Error
                        log error "VM $vm_id - Merge diff backup '$(basename $first_diff)' '$(basename $second_diff)' to '$(basename "$merged_diff")'"
                        do_run "rm -f $merged_diff"

                        if [ "$needs_decompress" == true ]; then
	                        # remove the temporary decompressed diff files
	                        do_run "rm $first_diff.raw $second_diff.raw"
	                    fi

                        return 1
                    fi
                fi
            fi

            let index++
        done
    done
}

function get_config_file(){
    local file_config=''

    if exist_file "$QEMU_CONF_CLUSTER/$vm_id$EXT_CONF"; then
        file_config=$(ls $QEMU_CONF_CLUSTER/$vm_id$EXT_CONF)

    elif exist_file "$LXC_CONF_CLUSTER/$vm_id$EXT_CONF"; then
        file_config=$(ls $LXC_CONF_CLUSTER/$vm_id$EXT_CONF)

    else
        log error "VM $vm_id - Unknown technology"

    fi

    echo "$file_config"
}

function get_image_spec(){
    local image_spec;
    local disk="$1"

    #if krbd enable
    image_spec=$(pvesm path "$disk" | grep '^/dev/rbd/' | sed -e "s/^\/dev\/rbd\///")
    if [ -z "$image_spec" ]; then
        image_spec=$(pvesm path "$disk" | grep '/ceph/' | awk '{ split($0,a,":"); print a[2]}')
    fi

    echo "$image_spec"
}

function reset(){
    parse_opts "$@"

    for vm_id in $vm_ids; do
        local file_config; file_config=$(get_config_file)
        [ -z "$file_config" ] && continue

        #decode disk
        local disk=''
        for disk in $(get_disks_from_config "$file_config"); do
            #check rbd device image-spec is pool-name/image-name
            local image_spec; image_spec=$(get_image_spec "$disk")
            [ -z "$image_spec" ] && continue

            local snap_name
            for snap_name in $(rbd snap ls "$image_spec" | \
                               awk '{print $2}' |
                               grep "$opt_label" | sort -r); do

                remove_snaphot "$image_spec@$snap_name" 0
            done
        done
    done;
}

function restore(){
    parse_opts "$@"
    local compress

    log info "ACTION: Restore image"

    for vm_id in $vm_ids; do
        get_path

        local title="EnterpriseVE BARC | Restore image"

        images=($(ls -r "$path_backup/"*{$EXT_IMAGE,$EXT_DIFF}{,.gz,.zz,.bz2} 2>/dev/null|xargs -n1 basename|awk '{ printf "%s %s\n", $0, $0}'))

        #select image to recovery
        local image;
        image=$(whiptail --title "$title" \
                --menu "Choose from available images:" \
                --notags 25 60 14 "${images[@]}" 3>&1 1>&2 2>&3)

        [ -z "$image" ] && exit 1

        #list all pools
        pools=($(rados lspools | awk '{printf "%s %s\n",$1,$1}'))

        #select timestamp
        local pool_name;
        pool_name=$(whiptail --title "$title" \
                    --menu "Choose destination Ceph pool:" \
                    --notags 25 60 14 "${pools[@]}" 3>&1 1>&2 2>&3)

        [ -z "$pool_name" ] && exit 1

        while true; do
            #name_import
            local name_import;
            name_import=$(whiptail --title "$title" \
                        --inputbox "Specify image name import" 8 78 \
                        "$(echo "$image" | awk '{ split($0,a,"."); print a[2]}')" 3>&1 1>&2 2>&3)

            [ -z "$name_import" ] && exit 1
            if ! rbd ls "$pool_name" | grep -q "$name_import"; then
                break;
            else
                whiptail --title "$title" --msgbox "Image $pool_name/$name_import already exist!" 8 78
            fi
        done

        if ! whiptail --title "$title" --yesno "Confirm restore $image to $pool_name/$name_import?" 8 78; then
            exit 1
        fi

        call_hook_script "restore-job-start" "-" "-"

        log info "Start restore $(date "+%F %T") $image"

        startts=$(date +%s)

        #Create actionplan
        [[ "$image" =~ $reimg ]]
        searchdisk=${BASH_REMATCH[3]}
        searchpool=${BASH_REMATCH[2]}
        local inchain=false
        local -a plan
        for backup_files in $(ls -r "$path_backup/"*{$EXT_IMAGE,$EXT_DIFF}{,.gz,.zz,.bz2} 2>/dev/null|xargs -n1 basename); do
            if [ "$backup_files" == "$image" ]; then
                inchain=true
            fi
            if [ "$inchain" == true ]; then
                [[ "$backup_files" =~ $reimg ]]
                foundpool=${BASH_REMATCH[2]}
                founddisk=${BASH_REMATCH[3]}
                ext=${BASH_REMATCH[4]}
                if [ "$founddisk" == "$searchdisk" ] && [ "$foundpool" == "$searchpool" ]; then
                    plan=("$backup_files" "${plan[@]}")
                    if [[ "$ext" == "img" ]]; then
                        break
                    fi
                fi
            fi
        done
        #Execute actionplan
        local backup=''
        for backup in "${plan[@]}"; do
            [[ "$backup" =~ $reimg ]]
            local timestamp_snap; timestamp_snap=${BASH_REMATCH[1]}
            local ext; ext=${BASH_REMATCH[4]}
            local cext; cext=${BASH_REMATCH[5]}
            case "$cext" in
                "gz" )
                    compress="gunzip -c"
                    ;;
                "bz2" )
                    compress="bzip2 -d"
                    ;;
                "zz" )
                    compress="pigz -dc -p $opt_compressthreads"
                    ;;
                "" )
                    compress="cat"
                    ;;
            esac
            local streamcksum
            log debug "ext: $ext"
            log debug "cext: $cext"
            case ".$ext" in
                "$EXT_IMAGE" )
                    log info "Initial import $backup"
                    cmd="$compress '$path_backup/$backup'| tee >(rbd import --no-progress --image-format 2 - $pool_name/$name_import) | $opt_ckmethod"
                    log info "VM $vm_id - importcmd: $cmd"
                    streamcksum=$(eval "$cmd")
                    if [ -e "$path_backup/$backup.${ckext[$opt_ckmethod]}" ]; then
                        storedcksum=$(<$path_backup/$backup.${ckext[$opt_ckmethod]})
                        if [ "$storedcksum" == "$streamcksum" ]; then
                            log info "VM $vm_id - Checksum match: ($storedcksum / $streamcksum)"
                        else
                            log error "VM $vm_id - Checksum missmatch. Check chain. ($storedcksum / $streamcksum)"
                            exit 1
                        fi
                        bytecount=$((bytecount+$(sum_size_file "$path_backup/$backup")))
                        uncompressedbytecount=$((uncompressedbytecount+$(< $path_backup/$backup.${ckext[$opt_ckmethod]}.size)))
                    fi
                    local snap_name_restore="$snap_name_prefix$timestamp_snap"
                    do_run "rbd snap create $pool_name/$name_import@$snap_name_restore"
                    ;;
                "$EXT_DIFF" )
                    log info "Differential $backup"
                    cmd="$compress '$path_backup/$backup' | tee >(rbd import-diff --no-progress - $pool_name/$name_import) | $opt_ckmethod"
                    log info "VM $vm_id - importcmd: $cmd"
                    streamcksum=$(eval "$cmd")
                    if [ -e "$path_backup/$backup.${ckext[$opt_ckmethod]}" ]; then
                        storedcksum=$(<$path_backup/$backup.${ckext[$opt_ckmethod]})
                        if [ "$storedcksum" == "$streamcksum" ]; then
                            log info "VM $vm_id - Checksum match: ($storedcksum / $streamcksum)"
                        else
                            log error "VM $vm_id - Checksum missmatch. Check chain. ($storedcksum / $streamcksum)"
                            exit 1
                        fi
                        bytecount=$((bytecount+$(sum_size_file "$path_backup/$backup")))
                        uncompressedbytecount=$((uncompressedbytecount+$(< $path_backup/$backup.${ckext[$opt_ckmethod]}.size)))
                    fi
                    ;;
            esac
        done

        #remove all snapshots
        log info "Remove all snapshots"
        do_run "rbd snap purge $pool_name/$name_import"

        log info "Backup $image restored in $pool_name/$name_import with success!"
        log info "Consider to manually create VM/CT and change config file from backup adapting restored image."

        call_hook_script "restore-job-end" "-" "-"
        endts=$(date +%s)
        log info "End restore $(date "+%F %T")"
        local -i runtime=$(expr $endts - $startts)
        local -i bps=$(expr $uncompressedbytecount/$runtime)

        log info "$(bytesToHuman "$uncompressedbytecount") restored in $runtime Seconds. [$(bytesToHuman "$bps")/s] [Compressed Size $(bytesToHuman "$bytecount")]"
        map_vmids_to_host

        log info "Issuing qm-rescan"
        do_run "ssh root@${pvnode[$vm_id]} qm rescan"

        break;
    done
}

function status(){
    parse_opts "$@"

    local print_header=1

    for vm_id in $vm_ids; do
        get_path
        local image=''
        local backup=''
        local ckregex='^.*.(md5|sha1|sha224|sha384|sha512)$'
        for backup in $(ls -r "$path_backup/"*{$EXT_IMAGE,$EXT_DIFF}{,.gz,.zz,.bz2} 2>/dev/null); do
            [[ "$backup" =~ $reimg ]]
            local ext; ext=${BASH_REMATCH[4]}
            local cext; cext=${BASH_REMATCH[5]}
            local image; image=${BASH_REMATCH[3]}
            local pool=${BASH_REMATCH[2]}
            local ts=${BASH_REMATCH[1]}
            if [ $print_header -eq 1 ]; then
                print_header=0
                echo "VM   TYPE COMP        SIZE UNCOMP       BACKUP           IMAGE"
            fi
            local ckformat=($(ls $backup.{md5,sha1} 2>/dev/null ))
            if [[ "$ckformat" =~ $ckregex ]]; then
                ckformat=${BASH_REMATCH[1]}
                local uncompressed=$(<"$backup.$ckformat.size")
                if [[ "$ckformat" != "" ]]; then
                    local cksum=$(<"$backup.$ckformat")
                    cksum=$(echo $cksum|cut -d' ' -f 1)
                fi
            fi
            printf "%-4s %-4s %-4s %10s %-12s %15s %15s \n" \
                    "$vm_id" \
                    "$ext" \
                    "$cext" \
                    "$(bytesToHuman "$(get_size_file "$backup")")" \
                    "$(bytesToHuman "$uncompressed")" \
                    "$ts" \
                    "$pool:$image"
            if  [[ "$ckformat" != "" ]]; then
                echo "                                  $ckformat: $cksum"
            fi
        done
    done
}

function bytesToHuman() {
    b=${1:-0}; d=''; s=0; S=(Bytes {K,M,G,T,P,E,Z,Y}iB)
    while ((b > 1024)); do
        d="$(printf ".%02d" $((b % 1024 * 100 / 1024)))"
        b=$((b / 1024))
        let s++
    done
    echo "$b$d ${S[$s]}"
}

function assemble(){
    local cmd_assemble; cmd_assemble=$(which eve4ceph-mdti 2>/dev/null)
    [ -z "$cmd_assemble" ] && { log error "eve4ceph-mdti (Merge Diff file To Image for Ceph) command not found. See https://github.com/EnterpriseVE/eve4ceph-mdti"; exit 1; }

    parse_opts "$@"

    for vm_id in $vm_ids; do
        get_path

        local title="EnterpriseVE BARC | Assemble"

        #list all image available
        images=($(ls "$path_backup/"*$EXT_IMAGE | \
                  xargs -n 1 basename | \
                  awk '{printf "%s %s\n",substr($1,13,length($1)-16),substr($1,13,length($1)-16)}'))

        #select image to recovery
        local image;
        image=$(whiptail --title "$title" \
                --menu "Choose from available images:" \
                --notags 25 60 14 "${images[@]}" 3>&1 1>&2 2>&3)

        [ -z "$image" ] && exit 1

        #list all date available
        timestamps=($(ls -r "$path_backup/"*$image* | \
                      xargs -n 1 basename | \
                      awk '{print substr($1,1,12),substr($1,1,2) "-" substr($1,3,2) "-" substr($1,5,2) "_" substr($1,7,2) ":" substr($1,9,2) ":" substr($1,11,2)}'))

        #select timestamp
        local timestamp
        timestamp=$(whiptail --title "$title" \
                    --menu "Choose from available date [$image]:" \
                    --notags 25 60 14 "${timestamps[@]}" 3>&1 1>&2 2>&3)

        [ -z "$timestamp" ] && exit 1

        local new_image="assemble-$image"
        if ! whiptail --title "$title" --yesno "Confirm assemble $image in $new_image?" 8 78; then
            exit 1
        fi

        call_hook_script "assemble-job-start" "-" "-"
        log info "Start assemble process"

        log info "Copy image to '$path_backup/$new_image'"
        do_run "cp $path_backup/*$image$EXT_IMAGE '$path_backup/$new_image$EXT_IMAGE'"

        #loop image and assemble
        local backup=''
        for backup in $path_backup/*$image*; do
            if [[ $backup == *"$EXT_DIFF" ]]; then
                log info "Assemble $backup"
                do_run "$cmd_assemble '$path_backup/$new_image$EXT_IMAGE' '$backup'"
            fi

            [[ $backup == "$path_backup/$timestamp.$image"* ]] && break;
        done

        log info "Backup $image assebled in $new_image with success!"

        call_hook_script "assemble-job-end" "-" "-"

        break;
    done
}

function end_process(){
    local -i rc=$1;
    if ! [[ -z "$startts" && -z "$endts" ]]; then
        local -i runtime=$(expr $endts - $startts)
        local -i bps=$(expr $bytecount/$runtime)
    fi
    log debug "startts:$startts endts:$endts runtime:$runtime bytecount:$bytecount bps:$bps"
    local subject="Ceph [VM:$vmok/$vmtotal SS:$snapshotok/$snapshottotal EX:$exportok/$exporttotal] [$(bytesToHuman "$bytecount")@$(bytesToHuman "$bps")/s]"
    [ $rc != 0 ] && subject="$subject [ERROR]"

    #send email
    local mail;
    local mailhead="Backup $imgcount Images in $vmcount VMs (Bytes: $bytecount)"
    for mail in $(echo "$opt_addr_mail" | tr "," "\n"); do
        do_run "cat '$LOG_FILE' | mail -s '$subject' '$mail'"
    done

    #remove log
    rm "$LOG_FILE"

    exit "$rc";
}

function main(){
    [ $# = 0 ] && usage;

    #command
    case "$1" in
        version) echo "$VERSION";;
        help) usage "$@";;
        create|destroy|enable|disable) cron_action_job "$@";;
        backup) backup "$@";;
        restore) restore "$@";;
        clean) clean "$@";;
        status) status "$@";;
        reset) reset "$@";;
        assemble) assemble "$@";;
        *) usage;;
    esac

    exit 0;
}

main "$@"
